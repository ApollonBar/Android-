考虑 JSON换成Protocol Buffer JSON可读性好，Protocol Buffer 对大数据量的传输支持更好
省去不必要的请求，或者合并多个单一请求为一个请求
使用GZIP来压缩请求信息和响应信息 OKHTTP会自带压缩
请求图片的优化 对请求的图片进行压缩处理缩小图片的大小 图片是android网络优化的重点
告诉服务器请求的图片大小，同事在一些图片存储的服务商也可以开启图片压缩的功能

使用WebP图片

通过网络提供WebP文件来减少图片加载的时间和节省网络带宽，WebP文件通常会比它的PNG或者JPG文件小，但会拥有同样的图片质量。
甚至是使用有损的设置，WebP也可以输出一个和原图几乎完全一样的图片。
安卓系统从Android4.0（API 14）添加了有损耗的WebP support并且在Android4.2（API 17）对无损的，清晰的WebP提供了支持。
使用WebP格式；同样的照片，采用WebP格式可大幅节省流量，相对于JPG格式的图片，流量能节省将近 25% 到 35 %；相对于 PNG 格式的图片，
流量可以节省将近80%。最重要的是使用WebP之后图片质量也没有改变。


动态修改图片

应用要求按指定的渲染大小来从网络上请求图片，这个渲染大小和设备规格有关，并且服务器提供的是合适大小的图片。
这样能够最小化网络上的数据传输，减少持有图片对内存的大量损耗，直接影响到性能的提高和用户满意度。
当用户不得不等待图片下载的时候用户体验就会有所下降，使用合适的图片尺寸有助于解决这些问题，
可以考虑让图片的请求都基于网络的类型或者网络连接的质量，这个尺寸可能会比目标值小。


打包网络请求

当接口设计不能满足我们的业务需求时. 例如可能一个界面需要请求多个接口, 或是网络良好, 处于Wifi状态下时我们想获取更多的数据等.
这时就可以打包一些网络请求, 例如请求列表的同时, 获取Header点击率较高的的item项的详情数据.
可以通过一些统计数据来帮助我们定位用户接下来的操作是高概率的, 提前获取这部分的数据.




调整数据传输

有几种方式让你的APP适应网络条件，提供一个较好的用户体验的，比如，对请求划分优先等级来最小化用户等待信息的时间。
也可以检测并适应较慢网络速度和发生网络连接的时候的发生的改变。

优先考虑带宽

不应该假设设备连接的网络是一个长时间持续并且稳定可靠的网络，app应该对网络请求划分优先级尽可能快地展示最有用的信息给用户。
立刻呈现给用户一些实质的信息是一个比较好的用户体验，相对于让用户等待那些不那么必要的信息来说。这可以减少用户不得不等待的时间，
增加APP在慢速网络时的实用性。
为了达到这个目的，对网络请求进行排序比如文本的获取应该在富媒体之前，文本请求一般都比较小，压缩更好，并且传输速度快，
这意味着你的APP可以快速地先显示内容。
在慢速网络的时候使用更少的带宽
你的APP传输数据的能力是否及时取决于网络连接，检测这些网络的质量并且调整你的APP使用网络的行为可以提供一个更好的用户体验。
使用下列的方法来检测外部不容易观察的网络质量，使用从这些方法返回的数据，你的APP应该调整对网络的使用来为用户的操作提供一个及时的响应
ConnectivityManager> isActiveNetworkMetered()
ConnectivityManager> getActiveNetworkInfo()
ConnectivityManager> getNetworkCapabilities(Network)
TelephonyManager> getNetworkType()
在一个慢速的网络连接中，考虑只下载低分辨率的媒体或者直接不下载。确保你的用户可以在慢速网络中继续使用你的APP，对于没有图片或者图片仍然在加载的情况
，应该先显示一个占位符，使用 Palette library创建一个动态的占位符，生成一个符合目标图片颜色的占位符
在Android 7.0或更高版本的设备上，用户可以打开Data Saver设置，可以帮助最小化数据的使用，Android 7.0扩展ConnectivityManager来检测Data Saver设置。
检测网络改变，然后修改APP的行为
网络质量不是固定不变的，它会随着地理位置，网络流量和当地人口密度发生改变。APP 应该检测网络中的改变并且相应地调整带宽，让APP可以更好地适应网络质量，可以实现下面的这些方法检测网络状态：
ConnectivityManager> getActiveNetworkInfo()
ConnectivityManager> getNetworkCapabilities(Network)
TelephonyManager> getDataState()


随着网络质量的下降，减少请求的数量，随着网络质量的提升，你可以提高你的请求量到最优级别。
在更高的网络质量下，不计费使用流量的网络，可以考虑预取数据让数据提前可用。从用户体验的立场，这可能意味着一个新闻阅读应用在2G网络下一次只能获取3篇文章，而在WIFI状态下一次可以获取20篇文章。
当网络连接状态发生改变时会发出CONNECTIVITY_CHANGE广播，APP在前台运行的情况下，可以通过注册广播接收器来接受这个广播，在接收广播以后，你应该再评估当前的网络状态并且调整你的UI，处理网络请求，不能够在manifest文件中声明这个广播Action，因为在Android7.0版本之后这个Action就被删除了。

IP直连与HttpDns；

DNS解析的失败率占联网失败中很大一种，而且首次域名解析一般需要几百毫秒。
针对此，我们可以不用域名，才用IP直连省去 DNS 解析过程，节省这部分时间。
另外熟悉阿里云的小伙伴肯定知道HttpDns：HttpDNS基于Http协议的域名解析，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，
可以避免Local DNS造成的域名劫持和跨网访问问题，解决域名解析异常带来的困扰。


请求频率优化

可以通过提供一个最佳的网络体验来增强用户体验，比如，你可以让你的APP在离线状态下依然可以使用，使用GcmNetworkManager和ContentProvider，
删除重复的网络请求。

让你的APP在离线状态下依然可用

在一些比较偏僻的地方，通常网络信号都不会很好，APP失去网络连接是很常见的事情。
创建一个能够在离线状态依然正常使用的APP意味着用户可以在任何时候和你的APP进行互动。
可以通过把网络数据保存在本地来实现这个需求，缓存数据，并且把发出的请求添加到队列中，当网络恢复的时候再及时发出。
在可能的情况下，app不应该通知用户网络已经失去连接了，只有当用户进行操作，并且这个操作一定需要网络连接的支持，才通知用户当前处于没有网络的状态。
当一个设备处于没有网络连接状态时，应用应该允许用户发出的网络请求，在网络连接恢复以后再执行这些网络请求。
一个例子就是一个邮件客户端允许用户在设备处于离线的状态下依然能够创建，发送，查看，移动和删除已经存在的邮件，就是因为这些操作被保存下来并且在网络恢复以后再执行。这样的话，APP就能够在设备有网络和没有网络的时候都提供一个相似的用户体验。
使用GcmNetworkManager和contentProvider确保你的APP使用数据库或者相似的结构来保存所有的数据到磁盘上，
这样它就能够在不管网络条件如何的情况下表现出极佳的体验，比如使用（SQLite和ContentProvider）缓存数据，
 GCM Network Manager ( GcmNetworkManager)提供一个健全的机制和服务器同步数据当 content providers (ContentProvider)缓存这些数据，
 结合来提供一个允许在离线状态继续使用的结构。
App应该缓存从网络上获取的内容，在发起持续的请求之前，app应该先显示本地的缓存数据。
这确保了app不管设备有没有网络连接或者是很慢或者是不可靠的网络，都能够为用户提供服务。
除去网络请求
一个离线优先的结构初始化时会尝试从本地获取数据，失败以后，从网络请求数据。从网络检索以后，
数据会缓存到本地。这就确保对于同一块数据发起网络请求只会发生一次，对随后的请求都会使用本地数据来完成请求。
为了达到这个，使用本地数据库来对数据持久化（通常使用android.database.sqlite 或者 SharedPreferences）
这个结构同样简化一个APP的流畅性，在离线和在线状态之间一方从网络获取数据保存到本地，另一方从缓存获取数据展示给用户。
对于短暂不持续的数据，也就是内容更新快的数据，使用一个有大小，或者时间限制的磁盘缓存，比如DiskLruCache，
数据通常不会发生改变的就只从网络请求一次然后缓存下来以后使用，这样的数据一般是图片或者非临时的文档比如新闻文章或者推送消息。



